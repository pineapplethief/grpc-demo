#!/usr/bin/env ruby

# frozen_string_literal: true

this_dir = File.expand_path(File.dirname(__FILE__))
lib_dir = File.join(this_dir, 'lib')
protobuf_dir = File.join(lib_dir, 'protobuf-autogenerated')
$LOAD_PATH.unshift(lib_dir) unless $LOAD_PATH.include?(lib_dir)
$LOAD_PATH.unshift(protobuf_dir) unless $LOAD_PATH.include?(protobuf_dir)

require 'awesome_print'

require 'db_setup'

require 'task'
require 'tasks_list'
require 'tasks_store'
require 'task_repository'

require './lib/protobuf-autogenerated/tasks_services_pb'

class TasksServer < Tasks::TasksService::Service
  SERVER_URL = '0.0.0.0:33377'

  def get_tasks(_request, _call)
    TasksList.new(tasks_repository.list).each
  end

  def add_task(request, _call)
    task = tasks_repository.add(request.task)

    Tasks::AddTaskResponse.new(
      task: Task.build_grpc_task(task)
    )
  end

  def finish_task(request, _call)
    task = tasks_repository.finish(request.id)
    grpc_task = Task.build_grpc_task(task)

    Tasks::FinishTaskResponse.new(task: grpc_task)
  end

  def delete_task(request, _call)
    tasks_repository.delete(request.id)

    Tasks::DeleteTaskResponse.new(success: true)
  end

  private

  def tasks_repository
    @repository ||= TaskRepository.instance
  end
end

def main
  server = GRPC::RpcServer.new
  server.add_http2_port(TasksServer::SERVER_URL, :this_port_is_insecure)
  server.handle(TasksServer)

  # Runs the server with SIGHUP, SIGINT and SIGTERM signal handlers to
  #   gracefully shutdown.
  # User could also choose to run server via call to run_till_terminated
  puts "server is listening on #{TasksServer::SERVER_URL}"

  server.run_till_terminated_or_interrupted([1, 'int', 'SIGTERM'])
end

main
